// Tam sürüm Tetris kodu (güncellenmiş kontrol sistemi ile)

<!DOCTYPE html><html lang="tr">
<head>
  <meta charset="UTF-8">
  <title>Tetris Gelişmiş</title>
  <style>
    canvas {
      background: #000;
      display: block;
      margin: 20px auto 10px auto;
      border: 2px solid white;
    }
    .controls {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }
    .controls button {
      width: 80px;
      height: 40px;
      margin: 0 5px;
      font-size: 20px;
      background-color: #333;
      color: white;
      border: none;
      border-radius: 5px;
    }
    .info {
      position: absolute;
      right: 10px;
      top: 10px;
      font-family: monospace;
    }
    .info table {
      border-collapse: collapse;
      background-color: #222;
      color: white;
      font-size: 14px;
    }
    .info th, .info td {
      border: 1px solid #444;
      padding: 5px 10px;
    }
  </style>
</head>
<body>
<canvas id="tetris" width="240" height="400"></canvas>
<div class="controls">
  <button onmousedown="startMoveLeft()" onmouseup="stopMove()">←</button>
  <button onclick="rotate()">⟳</button>
  <button onmousedown="startMoveRight()" onmouseup="stopMove()">→</button>
  <button onmousedown="startDrop()" onmouseup="stopDrop()">↓</button>
</div>
<div class="info">
  <table>
    <tr><th>Skor</th><td id="score">0</td></tr>
    <tr><th>Seviye</th><td id="level">1</td></tr>
  </table>
</div><script>
  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');
  const blockSize = 20;
  const cols = canvas.width / blockSize;
  const rows = canvas.height / blockSize;

  const colors = ['#00FFFF', '#FF0000', '#00FF00', '#FFFF00', '#FF00FF', '#FFA500', '#00CED1'];
  let board = Array.from({ length: rows }, () => Array(cols).fill(0));
  const shapes = [
    [[0, 1, 0], [1, 1, 1]],
    [[1, 1], [1, 1]],
    [[0, 0, 1], [1, 1, 1]],
    [[1, 0, 0], [1, 1, 1]],
    [[1, 1, 1, 1]],
    [[1], [1], [1], [1]]
  ];

  let current = createPiece();
  let score = 0;
  let level = 1;
  let dropInterval = 1000;
  let dropFast = false;
  let moveInterval;
  let dropTimer;

  function createPiece() {
    const shape = shapes[Math.floor(Math.random() * shapes.length)];
    const color = colors[Math.floor(Math.random() * colors.length)];
    return {
      shape,
      color,
      x: Math.floor((cols - shape[0].length) / 2),
      y: 0
    };
  }

  function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
    ctx.strokeStyle = '#111';
    ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
  }

  function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    board.forEach((row, y) => {
      row.forEach((val, x) => {
        if (val) drawBlock(x, y, val);
      });
    });
    drawShape(current);
  }

  function drawShape(piece) {
    piece.shape.forEach((row, y) => {
      row.forEach((val, x) => {
        if (val) drawBlock(x + piece.x, y + piece.y, piece.color);
      });
    });
  }

  function moveLeft() {
    current.x--;
    if (collide()) current.x++;
    draw();
  }

  function moveRight() {
    current.x++;
    if (collide()) current.x--;
    draw();
  }

  function rotate() {
    const shape = current.shape;
    const rotated = shape[0].map((_, i) => shape.map(row => row[i]).reverse());
    const old = current.shape;
    current.shape = rotated;
    if (collide()) current.shape = old;
    draw();
  }

  function drop() {
    current.y++;
    if (collide()) {
      current.y--;
      merge();
      clearLines();
      current = createPiece();
    }
    draw();
  }

  function startDrop() {
    dropFast = true;
    dropTimer = setInterval(drop, 50);
  }

  function stopDrop() {
    dropFast = false;
    clearInterval(dropTimer);
  }

  function startMoveLeft() {
    moveLeft();
    moveInterval = setInterval(moveLeft, 100);
  }

  function startMoveRight() {
    moveRight();
    moveInterval = setInterval(moveRight, 100);
  }

  function stopMove() {
    clearInterval(moveInterval);
  }

  function collide() {
    return current.shape.some((row, dy) =>
      row.some((val, dx) => {
        if (val) {
          const x = current.x + dx;
          const y = current.y + dy;
          return x < 0 || x >= cols || y >= rows || board[y]?.[x];
        }
        return false;
      })
    );
  }

  function merge() {
    current.shape.forEach((row, y) => {
      row.forEach((val, x) => {
        if (val) board[y + current.y][x + current.x] = current.color;
      });
    });
  }

  function clearLines() {
    outer: for (let y = rows - 1; y >= 0; y--) {
      for (let x = 0; x < cols; x++) {
        if (!board[y][x]) continue outer;
      }
      explodeRow(y);
      board.splice(y, 1);
      board.unshift(Array(cols).fill(0));
      score += 10;
      updateScore();
      y++;
    }
  }

  function explodeRow(y) {
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        for (let x = 0; x < cols; x++) {
          drawBlock(x, y, i % 2 === 0 ? 'red' : 'yellow');
        }
      }, i * 100);
    }
  }

  function updateScore() {
    document.getElementById('score').textContent = score;
    const newLevel = Math.floor(score / 100) + 1;
    if (newLevel > level) setLevel(newLevel);
  }

  function setLevel(newLevel) {
    level = newLevel;
    document.getElementById('level').textContent = level;
    dropInterval = 1000 - (level - 1) * 100;
    if (dropInterval < 100) dropInterval = 100;
  }

  let dropCounter = 0;
  function gameLoop() {
    dropCounter++;
    if (!dropFast && dropCounter >= dropInterval / 50) {
      drop();
      dropCounter = 0;
    }
    draw();
    requestAnimationFrame(gameLoop);
  }
  gameLoop();
</script></body>
</html>